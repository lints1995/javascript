let c = 0.1 + 0.2;
// 计算机使用二进制进行计算 我们可以模拟计算机的二进制计算，使用a.toString(2)把十进制的数转换成二进制
//0.1 的二进制 0.0001100110011001100110011001100110011001100110011001101
// 0.2 的二进制 0.001100110011001100110011001100110011001100110011001101
// 计算机计算标准按照 IEEE 754
// 相加计算完成后 会将二进制转换成十进制，但是计算机存储不了这么长的数 就会丢失后面的数字换出来的数字就不是想要的计算结果了
// 比如得出的结果是 0.001100110011001100110011001100110011 丢失这部分 00110012110011001101
// 0.001100110011001100110011001100110011 这部分转换出来就是0.3000000000004

// 解决方案-
parseFloat((0.1 + 0.2).toFixed(2));
//保留两位小数，四舍五入 toFixed 后面的数字会被抛弃，如果在*数量这种情况，量比较大就会带来大的误差

// 方案二
// 整数运算不会存在精度丢失问题
// 我们可以扩大小数的幂次方让它变成整数，再除以幂次方
function calcFloat(num1, num2) {
  const pow =
    num1.length > num2.length
      ? num1.toString().split(".")[1].length
      : num2.toString().split(".")[1].length;
  let multiple = Math.pow(10, pow);
  return (num1 * multiple + num2 * multiple) / multiple;
}
console.log(calcFloat(0.1, 0.2));
